%!TEX root = ../elaboration.tex
\chapter{System Implementation}
\label{cha:implementation}
% -----//-----
% \begin{enumerate}
%     \item Raspberry Pi
%           \begin{enumerate}
%               \item quais os algoritmos
%                     \begin{enumerate}
%                         \item Dribbles
%                         \item Saltos
%                         \item Passos/Distância/Posição
%                         \item Tempo parado/andar/correr
%                     \end{enumerate}
%               \item operações sensores
%               \item como se controlam os sensores
%               \item como são enviados os dados (mqtt)
%               \item feito em node
%           \end{enumerate}
%     \item Server
%           \begin{enumerate}
%               \item REST API feita em Node
%               \item DB em mySQL, explicar modelo
%               \item como troca mensagens com o rPi
%           \end{enumerate}
%     \item Cliente
%           \begin{enumerate}
%               \item Feito em React
%               \item Permite gerir equipas, jogadores e jogos
%               \item métricas por jogo, vários sensores por jogador
%           \end{enumerate}
% \end{enumerate}aaa
% -----//-----\\

The description of the System Implementation according to the proposed architecture will be separated in the three segments: Edge, Server and Client. Figure~\ref{fig:architectureImplementation} represents the implemented architecture.

\begin{figure}
    \centering
    \includegraphics[width=.6\textwidth]{BLESportsTrackerArchiteture.pdf}
    \caption{Implemented Architecture}
    \label{fig:architectureImplementation}
\end{figure}

\section{Edge}

As described in section~\ref{subsec:edge}, the edge segment is composed by one or more IMU Sensors and one or more \gls{EPU}.

The IMU Sensors used in the implementation phase are armed with 3-axis accelerometer, which measures the specific force in $m/s^2$, 3-axis gyroscope, which measures the angular rate in $^\circ/s$, and 3-axis magnetometer, which measures the strength of magnetic fields, in $\mu T$. The \gls{IMU} sensors used also have a battery, internal storage, and communicate through Bluetooth Low Energy.

In this phase, a Raspberry Pi was chosen to have the role of \gls{EPU}. A Raspberry Pi is a single-boarded, small and low-cost computer developed by the Raspberry Pi Foundation, with the goal of enabling people of all ages to explore computing.
%REFERENCE https://www.raspberrypi.org/help/what-%20is-a-raspberry-pi/
It was chosen for this system for its easy accessability in the market, reduced size, high portability and low price, its wide range of features, like Bluetooth and WiFi communications, and being a good platform for developing an application prototype.

The number of IMU sensors used can vary in each player by the number of metrics being measured (different metrics may require the use of more sensors) and the number of players being tracked.

As the number of sensors can grow, and due to the limitation of the number of connections to a Bluetooth receiver,
%REFERENCE http://dev.ti.com/tirex/content/simplelink_academy_cc26x2sdk_1_15_03_10/modules/ble5stack/ble_connections/ble_connections.html
the number of Raspberry Pi's can also grow, in order to establish connection with all the IMU Sensors.
This also helps to share the computation of the game metrics between the Raspberry Pi's.

\subsection{IMU Sensor Control and Communication}
\label{subsec:imuControl}
The role of the IMU Sensors is to receive instructions issued by the user, and send accelerometer and gyroscope raw data to the Raspberry Pi they are connected, over Bluetooth.

The following operations are supported by IMU Sensors:
\begin{itemize}
    \item State control
          \begin{itemize}
              \item Start Raw Data Collection
              \item Stop Raw Data Collection
              \item Shutdown
          \end{itemize}
    \item Sample Rate
    \item MPU Configuration
\end{itemize}

The IMU Sensors must pair with a Raspberry Pi, which is searching for the known sensors. After being paired, the operations can be communicated to the IMU Sensors through Bluetooth Notifications.

Before starting the data collection, it is necessary to set the sample rate to 50 Hz (necessary for the metrics algorithms), and to activate the gyroscope and the magnetometer sensor by changing the MPU Configuration. By default only the accelerometer sensor is active.

To start collecting data from an IMU Sensor, it is needed to provide information like the MAC Address of the sensor, an identification of the game being played and the player wearing the sensor (because the sensors can be changed from game to game between the players). It is also needed to send the position of the sensor in the player's body, to calculate the metrics, as each algorithm uses data collected from a different part of the body.

The IMU Sensors send time ($ms$), accelerometer ()$m/s^2$) and gyroscope ($^\circ/s$) data in a bite array, which is then converted to human-readable values. The magnetometer data isn't used, so it is discarded. An example of raw data sent by the IMU Sensors can be seen in Table~\ref{tab:raw}.

\begin{table}
    \centering
    \caption{Raw Data Example}
    \label{tab:raw}
    \begin{tabular}{lllllll}
        time & accX    & accY     & accZ    & gyrX    & gyrY    & gyrZ     \\
        0.02 & 0,46178 & -0,83982 & 9,46772 & 0,07084 & 0,05007 & -0,03089 \\
        0.04 & 0,44264 & -0,80991 & 9,42465 & 0,07031 & 0,04954 & -0,03196 \\
        0.06 & 0,42948 & -0,83384 & 9,42106 & 0,07031 & 0,04900 & -0,03196 \\
        0.08 & 0,41991 & -0,82786 & 9,44858 & 0,07031 & 0,04954 & -0,03196 \\
        0.10 & 0,43666 & -0,82666 & 9,41030 & 0,06978 & 0,04794 & -0,03196
    \end{tabular}
\end{table}


When the metrics are calculated, they are sent to the server via MQTT, to be stored there.
%REFERENCE citar mqtt?
%TODO gls MQTT
The Raspberry Pi's don't store data, they only server as a vehicle of instructions and data between the server and the sensors.

A single Raspberry Pi is then responsible by maintaining the connection with several IMU Sensors; communicate instructions; receive accelerometer, gyroscope and magnetometer data, and stores it temporarily; depending on the position of the sensor, calculate the according metrics algorithms with the received data; send the calculated metrics to the Server.


\subsection{Game Metrics}
To achieve the goal to collect insightful information of a basketball game, a set of game metrics were chosen, focusing on three body locations: foot, lower back and hand.

Using the sensor in the foot we can infer the number of steps, traveled distance and player trajectory.

In the hand, it is possible to detect the number of dribbles, and time dribbling. With this, it is also possible to calculate the time of ball possession of the whole team.

In the lower back, the sensor was used to collect data and analyze it to detect the number of jumps and time in air.

The following sections will explain in detail how the metrics are calculated, using raw data.

\subsubsection{Trajectories}
\label{subsubsec:trajectories}
%TODO falar que este algoritmo deu bons resultados quando apenas se andava, mas não é mmuito fiável a correr. Also a distância era bastante mais alta que a trajetória real pecorrida
% To track the player's trajectories, the selected approach was Implementing a Pedestrian Tracker Using Inertial Sensors~\cite{tutorial},

\subsubsection{Steps}
The detection of steps takes advantage of the algorithm explained in ~\ref{subsubsec:trajectories}, especially the Zero-Velocity Detection.
Whenever a Zero-Velocity is detected, it is recorded in a binary array (zeros meaning no movement, ones meaning movement). Afterwards, when the Trajectory detection algorithm ends, the array is analysed.

The analysis is made by counting the meaningful "sections"{} of ones. Listing~\ref{lst:stepArray} shows an example of a step detection array, where we can clearly see there are two main sections"{} of ones, meaning that using this example the algorithm should count two steps.
\lstset{caption=Steps Array Example, label=lst:stepArray}
\begin{lstlisting}
[0000000000100001111111111111111000100000000000000010111111111111111111100110000000000]
\end{lstlisting}

However the algorithm must take into account the outliers, and shouldn't identify it as steps. This can be ensured by only counting a step after a number of consecutive ones is observed. If two consecutive zeros appears in the middle, the possible step is discarded.
The behavior of the algorithm is described in Listing~\ref{lst:stepAlgorithm}.

\lstset{language=Matlab, caption=Steps Counting Algorithm, label=lst:stepAlgorithm}
\begin{lstlisting}
    steps = 0;
    no_ones = 0;
    last = 0;
    for idx = 1:data_size
        current = walking(idx);
        if (last == 0 && current == 1)
            no_ones++;
        elseif (last == 1 && current == 1)
            no_ones++;
            if (no_ones == 12)
                steps++;
            endif
        elseif (last == 0 && current == 0)
            no_ones = 0;
        endif
        last = current;
    endfor
\end{lstlisting}

This algorithm can be improved in the detection of the "sections"{} of ones, as it can sometimes fail. For example, if in one step sequence we had 3 occurrences of zeros inside a large sequence of ones, the algorithm would count 2 steps instead of 1 step  However, when testing the results were satisfactory, so no more work was done in the development of this algorithm.

\subsubsection{Dribbles}
% The analysis of dribbling is made using an \gls{IMU} Sensor placed in the wrist of the dominant hand, as shown in figure %TODO arranjar figura
% , and uses the data from the Y-axis accelerometer and X-axis gyroscope.

\subsubsection{Jumps}

\section{Server}
The server is built as a Rest API, developed with Node.js, and taking advantage of the Express framework that enables a fast development of Web Applications and API's. %REFERENCE nodejs, rest, api, express

To manage peripherals (IMU Sensors), Players, Teams, and Games, there are API endpoints for each one of this resources, and all the data is saved in a MySQL Database.

\subsection{Database Model}

The database, developed in MySQL, was designed in order to store all the data from the main resources, its relations and meaningful data in those relations. Figure~\ref{fig:database} shows the database model, which will be explained in detail.

\begin{figure}
    \centering
    \includegraphics[width=.7\textwidth]{SQL2.pdf}
    \caption{Database Model}
    \label{fig:database}
\end{figure}

The main resources are represented in the following tables: Peripherals; Players; Teams; Games; Metrics.

Each entry in the Peripheral table represents an \gls{IMU} Sensor. It's stored the peripheral MAC Address, and its attributed number for easier identification.

In the Players table, each player has stored its identifier,  name, and an identifier of the team they belong to. %could store age, height, weight, position

The Team table only stores the name of the team and its identifier. %could store city, year of foundation, score in the league, coach....

To store information about a game, the Game table has its identifier, the date of the game, and a reference for both teams attending the game. %could store where it is, the score of the game, the referee....

For the metrics, each player has a set of metrics per game, with the data gathered from all the \gls{IMU} Sensors he's using. The metrics being currently stored are: number of steps and distance traveled; number of jumps; number of dribbles and dribbling time; time spent being still, walking and running.

One of the features of the system is to be able to handle multiple peripherals per player, in different body positions, that can be changed between games. To store this information, two tables are needed: one that stores the relation between the player and the game (Player\_Game Table), and another that relates that with a peripheral (PG\_Peripheral Table), storing where the peripheral is placed in the player's body.

\subsection{API Description}
The Developed API exposes endpoints to control the different resources available in the system. Those resources are:
\begin{itemize}
    \item Peripherals (IMU Sensors)
    \item Players
    \item Teams
    \item Games
\end{itemize}

%TODO mostrar mensagens de exemplo?
\subsubsection{Teams}
\label{subsubsec:teams}
The Teams endpoint enables the \gls{CRUD} actions over the teams of the system.

It lets the user create a new team, given their name, the ability to consult all the teams registered in the system, to consult a specific team and their respective information or the players that belong to that team. This endpoint also serves to update information about a team or to delete the team from the system.

\subsubsection{Players}
\label{subsubsec:players}
The Players endpoint provides the user the \gls{CRUD} actions over the players of the system.

It enables the creation of a new player, given their name and the team they belong to, the ability to consult all the players registered in the system, or to consult a specific player and their respective information; for a given player, this endpoint also serves to update information or to delete the player from the system.

\subsubsection{Games}
\label{subsubsec:games}
This endpoint, besides providing Create, Read and Delete operations for the games, also manages the attribution of peripherals to each player, in multiple parts of their body, and also to fetch the metrics for each player.

For the Create operation, it is possible to create a game providing the date of the game and the two teams that are playing the game.

For the Read operation, it is possible to get a list of the games (that already occurred or that will occur), get the main info about a specific game (the date and the teams) or to get specific info about a specific game (like the players of each team, and the assigned peripherals for each player).

For the Delete operation, it is possible to delete a game.

To manage the peripherals for each player, it is possible to assign a peripheral to a player in a given game, providing the player identifier, the peripheral address and the location of the body where the \gls{IMU} Sensor is located, and it is possible to remove this assignment.

It is also possible to read the metrics for each player, and to get a sum of the dribbling time for each team, which gives an insight for the total ball possession during a game.

\subsubsection{Peripherals}
\label{subsubsec:peripherals}
The peripherals endpoint enables the control of the \gls{IMU} Sensors from the Client app, and stores temporary state on the peripherals, like what are the currently connected peripherals, and which ones are collecting data.

As specified in Subsection~\ref{subsec:imuControl}, there are 3 main controls that can be sent to the \gls{IMU} Sensors: start, stop or shutdown. The Peripherals endpoint allows 3 ways of sending this command to the Edge segment: control only one given peripheral, control all the peripherals in a game or control all connected devices.

The control instructions are sent to the Edge Segment through the MQTT protocol, and are activated notifications to receive updates from the Edge. For example, if the instructions to start all the peripherals in a game, the server will be awaiting for notifications from each of the peripherals, with the calculated game metrics, depending on the position of the \gls{IMU} Sensor in the body of the player.


\section{Client}
% The client application was developed in React, with the goal of controlling the IMU Sensors, and manage teams, players and games. It should also display Player and Team game-related metrics.

\begin{itemize}
    \item Descrever  funcionalidades, que interagem com API
    \item Screenshots
\end{itemize}

%TODO some of the features explained above of the API weren't implemented, like editing and deleting players and teams